---
phase: 05-ml-speed-restoration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/services/control/ml_controller.py, config/config.yaml]
autonomous: true
---

<objective>
Implement save/restore of cutting speeds around ML cuts.

Purpose: When ML mode adjusts speeds during cutting, the original operator-set speeds are lost. This feature saves speeds before ML starts and restores them after cutting completes, so the next cut starts from operator-preferred values instead of ML-modified values.

Output: MLController that automatically saves/restores kesme and inme speeds around each cutting session.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/services/control/ml_controller.py
@src/services/modbus/writer.py
@src/domain/enums.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add speed save/restore configuration</name>
  <files>config/config.yaml</files>
  <action>
Add `speed_restore` section under `ml:` config block with:
- `enabled: true` — Master enable/disable for feature
- `restore_on_cutting_end: true` — Whether to restore speeds when cutting finishes

Add config after the `write_thresholds` section in the ml config block.

Example structure:
```yaml
ml:
  # ... existing config ...

  # Speed restoration after ML cuts
  speed_restore:
    enabled: true                    # Enable save/restore feature
    restore_on_cutting_end: true     # Restore original speeds when cutting ends
```
  </action>
  <verify>cat config/config.yaml | grep -A3 "speed_restore"</verify>
  <done>Config section exists with enabled and restore_on_cutting_end options</done>
</task>

<task type="auto">
  <name>Task 2: Implement speed save/restore in MLController</name>
  <files>src/services/control/ml_controller.py</files>
  <action>
Modify MLController to save speeds when cutting starts and restore them when cutting ends:

1. **Add instance variables in __init__:**
   - `self._saved_kesme_hizi: Optional[float] = None`
   - `self._saved_inme_hizi: Optional[float] = None`
   - `self.speed_restore_enabled` — from config['ml'].get('speed_restore', {}).get('enabled', False)
   - `self.restore_on_cutting_end` — from config['ml'].get('speed_restore', {}).get('restore_on_cutting_end', True)

2. **Add _save_original_speeds method:**
   ```python
   def _save_original_speeds(self, kesme_hizi: float, inme_hizi: float):
       """Save original speeds before ML starts adjusting."""
       self._saved_kesme_hizi = kesme_hizi
       self._saved_inme_hizi = inme_hizi
       logger.info(
           f"Original speeds saved: kesme={kesme_hizi:.1f}, inme={inme_hizi:.1f}"
       )
   ```

3. **Add async _restore_original_speeds method:**
   ```python
   async def _restore_original_speeds(self):
       """Restore original speeds after cutting ends."""
       if not self.restore_on_cutting_end:
           return
       if self._saved_kesme_hizi is None or self._saved_inme_hizi is None:
           return

       try:
           success = await self.modbus.writer.write_speeds(
               self._saved_kesme_hizi,
               self._saved_inme_hizi
           )
           if success:
               logger.info(
                   f"Original speeds restored: kesme={self._saved_kesme_hizi:.1f}, "
                   f"inme={self._saved_inme_hizi:.1f}"
               )
           else:
               logger.warning("Failed to restore original speeds")
       except Exception as e:
           logger.error(f"Error restoring speeds: {e}")
   ```

4. **Modify calculate_speeds method:**
   In the "Mark as cutting" block (where `self.is_cutting = True`), add speed saving:
   ```python
   if not self.is_cutting:
       self.is_cutting = True
       logger.info("Cutting started - ML controller activated")
       # Save original speeds before ML starts adjusting
       if self.speed_restore_enabled:
           self._save_original_speeds(
               raw_data.serit_kesme_hizi,
               raw_data.serit_inme_hizi
           )
   ```

5. **Modify _reset_cutting_state to be async:**
   - Change signature to `async def _reset_cutting_state(self):`
   - Before clearing state, call `await self._restore_original_speeds()` if speed_restore_enabled
   - Clear saved speeds at the end: `self._saved_kesme_hizi = None`, `self._saved_inme_hizi = None`
   - Update all callers of _reset_cutting_state to use await

6. **Update calculate_speeds caller:**
   Since _reset_cutting_state becomes async, the call at line 158 needs to be:
   `await self._reset_cutting_state()`
   (calculate_speeds is already async so this works)

7. **Log init message:**
   Update the logger.info in __init__ to include speed_restore status.

IMPORTANT: The modbus service in MLController is `self.modbus` which is an AsyncModbusService. Check if it has a writer attribute or if write_speeds is called differently. If self.modbus doesn't have a writer, you'll need to get access to ModbusWriter through the service.

Looking at the codebase: The write happens through DataProcessingPipeline which has access to ModbusWriter. Since MLController doesn't have direct access to writer, add a writer parameter to __init__:
- Add `modbus_writer` parameter to __init__
- Store as `self.writer = modbus_writer`
- Use `await self.writer.write_speeds(...)` in restore method

Check where MLController is instantiated (ControlManager) and pass the writer from there.
  </action>
  <verify>grep -n "speed_restore\|_saved_kesme\|_restore_original" src/services/control/ml_controller.py</verify>
  <done>
- Config options read in __init__
- Speeds saved on cutting start (when is_cutting becomes True)
- Speeds restored on cutting end (in _reset_cutting_state)
- Feature can be enabled/disabled via config
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire ModbusWriter to MLController</name>
  <files>src/services/control/manager.py</files>
  <action>
MLController needs access to ModbusWriter to write the restored speeds. Update ControlManager to pass the writer:

1. **Check how ControlManager creates MLController:**
   Currently: `self.ml_controller = MLController(config, modbus_service, ml_db_service)`

2. **Determine how to get ModbusWriter:**
   - ModbusWriter is likely created in DataProcessingPipeline or ApplicationLifecycle
   - Find where it's instantiated and pass it to ControlManager, then to MLController
   - OR: Since modbus_service (AsyncModbusService) is already passed, check if ModbusWriter can be created using that service

3. **Option A - Pass writer to ControlManager:**
   - Add `modbus_writer` parameter to ControlManager.__init__
   - Pass it through to MLController
   - Update caller (ApplicationLifecycle or wherever ControlManager is created)

4. **Option B - Create writer in ControlManager:**
   If ModbusWriter just needs AsyncModbusService and config:
   ```python
   from ..modbus.writer import ModbusWriter
   # In __init__:
   self.modbus_writer = ModbusWriter(
       modbus_service,
       config['modbus']['registers'],
       config['control']['speed_limits']
   )
   # Pass to MLController:
   self.ml_controller = MLController(config, modbus_service, ml_db_service, self.modbus_writer)
   ```

5. **Update MLController.__init__ signature:**
   ```python
   def __init__(self, config: dict, modbus_service, db_service, modbus_writer=None):
       # ...
       self.writer = modbus_writer
   ```

Choose the simpler option that maintains existing architecture patterns.
  </action>
  <verify>grep -n "ModbusWriter\|modbus_writer\|self.writer" src/services/control/manager.py src/services/control/ml_controller.py</verify>
  <done>
- MLController has access to ModbusWriter
- Writer is properly instantiated and passed through the dependency chain
- No circular imports or architecture violations
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Config option exists in config/config.yaml
- [ ] MLController saves speeds when cutting starts (log message visible)
- [ ] MLController restores speeds when cutting ends (log message visible)
- [ ] Feature can be disabled via config (speed_restore.enabled: false)
- [ ] No import errors or runtime exceptions
- [ ] python -c "from src.services.control.ml_controller import MLController" succeeds
</verification>

<success_criteria>
- All tasks completed
- Speed save/restore logic implemented
- Feature is configurable (can be enabled/disabled)
- No breaking changes to existing ML functionality
</success_criteria>

<output>
After completion, create `.planning/phases/05-ml-speed-restoration/05-01-SUMMARY.md`
</output>
