---
phase: 04-modbus-timeout
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/services/modbus/client.py, config/config.yaml]
autonomous: true
---

<objective>
Add connection cooldown and operation timeouts to AsyncModbusService to prevent application freezing when PLC is unreachable.

Purpose: When Modbus connection is unavailable, every read/write attempt currently triggers a reconnection that blocks for 5 seconds. At 10 Hz processing rate, this causes the application to freeze. Adding cooldown prevents repeated connection attempts, and explicit timeouts ensure operations never exceed expected bounds.

Output: Modified AsyncModbusService with graceful degradation when PLC is unreachable.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/services/modbus/client.py
@config/config.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add connection cooldown mechanism to AsyncModbusService</name>
  <files>src/services/modbus/client.py</files>
  <action>
Modify AsyncModbusService class to add connection cooldown:

1. Add new instance variables in __init__:
   - `self._last_connect_attempt: float = 0` — timestamp of last connection attempt
   - `self._connect_cooldown: float = config.get('connect_cooldown', 10.0)` — minimum seconds between connection attempts

2. Create new method `_should_attempt_connect() -> bool`:
   - Return True if enough time has passed since last connection attempt
   - Check: `time.monotonic() - self._last_connect_attempt >= self._connect_cooldown`
   - Log at DEBUG level when skipping due to cooldown

3. Modify `connect()` method:
   - Record `self._last_connect_attempt = time.monotonic()` BEFORE attempting connection
   - Wrap the `await self._client.connect()` call with `asyncio.wait_for(timeout=self.config.get('timeout', 5.0))` to ensure hard timeout
   - Catch `asyncio.TimeoutError` and log as connection timeout, return False

4. Modify `read_holding_registers()` method:
   - Replace `await self.connect()` with check: `if self._should_attempt_connect(): await self.connect()`
   - If not connected and cooldown not elapsed, immediately return None (skip operation)
   - Add `asyncio.wait_for` wrapper around the actual read operation with timeout

5. Modify `write_register()` method:
   - Same pattern as read_holding_registers: check cooldown before connect attempt
   - Add `asyncio.wait_for` wrapper around write operation with timeout

Import `time` at top of file for `time.monotonic()`.
  </action>
  <verify>
Run: python -c "from src.services.modbus.client import AsyncModbusService; print('Import OK')"
Verify: No syntax errors
  </verify>
  <done>
- AsyncModbusService has _last_connect_attempt and _connect_cooldown attributes
- _should_attempt_connect() method exists and returns bool
- connect() has asyncio.wait_for timeout wrapper
- read_holding_registers() and write_register() check cooldown before reconnect
- Operations wrapped with asyncio.wait_for timeouts
  </done>
</task>

<task type="auto">
  <name>Task 2: Add connect_cooldown to config.yaml</name>
  <files>config/config.yaml</files>
  <action>
Add `connect_cooldown` parameter to modbus section in config.yaml:

After line 24 (`retry_delay: 1.0`), add:
```yaml
  connect_cooldown: 10.0  # Minimum seconds between reconnection attempts (prevents blocking during PLC outage)
```

This allows operators to tune the cooldown period based on their PLC recovery characteristics.
  </action>
  <verify>
Run: python -c "import yaml; c = yaml.safe_load(open('config/config.yaml')); print(c['modbus']['connect_cooldown'])"
Expected output: 10.0
  </verify>
  <done>
- config.yaml modbus section has connect_cooldown: 10.0
- Comment explains purpose
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.services.modbus.client import AsyncModbusService"` succeeds
- [ ] `python -c "import yaml; yaml.safe_load(open('config/config.yaml'))['modbus']['connect_cooldown']"` returns 10.0
- [ ] No syntax errors in modified files
- [ ] Code follows project conventions (async patterns, logging)
</verification>

<success_criteria>
- AsyncModbusService prevents repeated connection attempts within cooldown period
- Operations have explicit timeout wrappers
- Config allows cooldown tuning
- Application will not freeze when PLC is unreachable
</success_criteria>

<output>
After completion, create `.planning/phases/04-modbus-timeout/04-01-SUMMARY.md`
</output>
