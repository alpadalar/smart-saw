---
phase: 12-ml-prediction-parity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/ml/preprocessor.py, src/services/control/ml_controller.py]
autonomous: true
---

<objective>
Fix ML prediction parity by aligning speed calculation logic with old codebase.

Purpose: The new code uses raw current speed values for percentage calculations, while the old code uses averaged speeds from buffers. This causes different speed adjustments even with identical ML predictions.

Output: Modified ml_controller.py and preprocessor.py that match old code behavior exactly.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Critical Files:**
@src/ml/preprocessor.py
@src/services/control/ml_controller.py

**Reference Files (OLD codebase):**
/media/workspace/eskiimas/smart-saw/src/control/ml/controller.py

**Root Cause Analysis:**

**Issue 1 - Speed Calculation Base Values (CRITICAL):**

OLD CODE (predict_coefficient lines 294-296):
```python
avg_akim, avg_sapma, avg_kesme_hizi, avg_inme_hizi = self._get_buffer_averages()
# ...
new_inme_hizi = avg_inme_hizi + coefficient  # Uses AVERAGED speed from buffer
```

NEW CODE (calculate_speeds lines 220-224):
```python
speed_changes = self._calculate_new_speeds(
    coefficient,
    raw_data.serit_kesme_hizi,  # Uses CURRENT RAW VALUE - WRONG!
    raw_data.serit_inme_hizi    # Uses CURRENT RAW VALUE - WRONG!
)
```

The OLD code:
1. Buffers 3 samples of akim, sapma, kesme_hizi, inme_hizi
2. Averages ALL buffer values to get avg_kesme_hizi, avg_inme_hizi
3. Uses these AVERAGED speeds as base for percentage calculations

The NEW code:
1. Buffers values in preprocessor
2. But then uses raw_data.serit_kesme_hizi directly (current value, not averaged)
3. This causes different percentage calculations and final speeds

**Issue 2 - Torque Clamping (Minor):**

NEW CODE preprocessor.py line 87-88:
```python
torque_percentage = max(0.0, min(torque_percentage, 100.0))  # Clamps input
```

OLD CODE _torque_to_current (lines 250-257):
```python
return (TORQUE_TO_CURRENT_A2 * (torque_percentage ** 2) + ...)  # No clamping
```

The new code clamps torque to [0, 100] before polynomial conversion.
The old code allows out-of-range values through the polynomial.

**Fix Strategy:**
1. Add kesme_hizi and inme_hizi averaging methods to preprocessor (or use existing buffers)
2. Modify _calculate_new_speeds to use averaged speeds instead of raw values
3. Remove torque clamping to match old behavior
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add method to get averaged speeds from preprocessor</name>
  <files>src/ml/preprocessor.py</files>
  <action>
Add a new method to MLPreprocessor that returns averaged speed values, matching the old code's _get_buffer_averages() behavior.

Add this method after get_model_input() (around line 200):

```python
def get_averaged_speeds(self) -> Tuple[float, float]:
    """
    Get averaged speed values from buffers.

    This matches old codebase behavior where speed calculations
    use averaged values, not raw current values.

    Returns:
        Tuple of (avg_kesme_hizi, avg_inme_hizi), or (0.0, 0.0) if buffers empty
    """
    if len(self.kesme_hizi_buffer) == 0 or len(self.inme_hizi_buffer) == 0:
        return (0.0, 0.0)

    avg_kesme = np.mean(list(self.kesme_hizi_buffer))
    avg_inme = np.mean(list(self.inme_hizi_buffer))

    return (avg_kesme, avg_inme)
```

Also add the Tuple import at the top of the file if not present.
  </action>
  <verify>grep -A 15 "def get_averaged_speeds" src/ml/preprocessor.py</verify>
  <done>get_averaged_speeds() method added to preprocessor returning averaged kesme_hizi and inme_hizi</done>
</task>

<task type="auto">
  <name>Task 2: Modify _calculate_new_speeds to use averaged speeds</name>
  <files>src/services/control/ml_controller.py</files>
  <action>
Modify calculate_speeds() method to use averaged speed values from preprocessor instead of raw values.

In calculate_speeds() around line 220, change:

FROM:
```python
# 7. Calculate new speeds
speed_changes = self._calculate_new_speeds(
    coefficient,
    raw_data.serit_kesme_hizi,
    raw_data.serit_inme_hizi
)
```

TO:
```python
# 7. Calculate new speeds using AVERAGED values (matches old codebase)
avg_kesme, avg_inme = self.preprocessor.get_averaged_speeds()
# Fall back to raw values if buffers empty (shouldn't happen after is_ready check)
if avg_kesme == 0.0 and avg_inme == 0.0:
    avg_kesme = raw_data.serit_kesme_hizi
    avg_inme = raw_data.serit_inme_hizi
    logger.warning("Using raw speed values - buffers empty")

speed_changes = self._calculate_new_speeds(
    coefficient,
    avg_kesme,
    avg_inme
)
```

This ensures the speed percentage calculations use the same averaged base values as the old codebase.
  </action>
  <verify>grep -A 12 "# 7. Calculate new speeds" src/services/control/ml_controller.py</verify>
  <done>_calculate_new_speeds now uses averaged speeds from preprocessor buffers</done>
</task>

<task type="auto">
  <name>Task 3: Remove torque percentage clamping</name>
  <files>src/ml/preprocessor.py</files>
  <action>
Remove the torque percentage clamping in torque_to_current() to match old code behavior.

In torque_to_current() method (around line 70-97), change:

FROM:
```python
def torque_to_current(self, torque_percentage: float) -> float:
    """..."""
    # Clamp to valid range
    torque_percentage = max(0.0, min(torque_percentage, 100.0))

    # Apply polynomial
    current = (
        self.poly_a2 * (torque_percentage ** 2) +
        self.poly_a1 * torque_percentage +
        self.poly_a0
    )

    return current
```

TO:
```python
def torque_to_current(self, torque_percentage: float) -> float:
    """
    Convert motor torque percentage to current using polynomial model.

    Model: f(x) = A2*x^2 + A1*x + A0
    Coefficients calibrated from motor datasheet and field measurements.

    Note: No clamping applied to match old codebase behavior.
    The polynomial handles any input value.

    Args:
        torque_percentage: Motor torque as percentage (typically 0-100)

    Returns:
        Estimated current in Amperes
    """
    try:
        # Apply polynomial (no clamping - matches old code)
        current = (
            self.poly_a2 * (torque_percentage ** 2) +
            self.poly_a1 * torque_percentage +
            self.poly_a0
        )
        return current
    except Exception:
        return 0.0
```
  </action>
  <verify>grep -A 20 "def torque_to_current" src/ml/preprocessor.py | head -25</verify>
  <done>torque_to_current() no longer clamps input, has try/except handling matching old code</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `grep -A 15 "def get_averaged_speeds" src/ml/preprocessor.py` shows new method
- [ ] `grep -A 12 "# 7. Calculate new speeds" src/services/control/ml_controller.py` shows averaged speeds usage
- [ ] `grep -A 20 "def torque_to_current" src/ml/preprocessor.py` shows no clamping, has try/except
- [ ] Python syntax check: `python -m py_compile src/ml/preprocessor.py src/services/control/ml_controller.py`
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Speed calculations now use averaged values from buffers (matching old code)
- torque_to_current() matches old code behavior (no clamping)
- No Python syntax errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-ml-prediction-parity/12-01-SUMMARY.md`
</output>
